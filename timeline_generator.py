#!/usr/bin/env python3

"""
Timeline Generator for Code Historian

This script generates visual timelines of code changes using Graphviz.
It reads the markdown files generated by code-historian and creates
visual representations of the changes over time.
"""

import os
import re
import sys
from datetime import datetime
from typing import Dict, List, NamedTuple
import graphviz

class Change(NamedTuple):
    """Represents a single code change."""
    timestamp: str
    categories: List[str]
    stats: Dict[str, int]
    file_name: str

def parse_markdown_file(file_path: str) -> List[Change]:
    """Parse a markdown file and extract change information."""
    changes = []
    current_timestamp = None
    current_categories = []
    current_stats = {}
    
    with open(file_path, 'r') as f:
        content = f.read()
        
    # Extract file name from the first line
    file_name_match = re.search(r'# Code Evolution Analysis for (.+)', content)
    file_name = file_name_match.group(1) if file_name_match else "Unknown"
    
    # Find all change sections
    sections = re.split(r'## Changes at ', content)[1:]
    
    for section in sections:
        # Extract timestamp
        timestamp = section.split('\n')[0].strip()
        
        # Extract categories
        categories = re.findall(r'\*\*(.*?)\*\*: .*', section)
        
        # Extract statistics
        stats = {}
        stats_match = re.search(r'Lines added: (\d+)\nLines removed: (\d+)\nNet change: (-?\d+)', section)
        if stats_match:
            stats = {
                'added': int(stats_match.group(1)),
                'removed': int(stats_match.group(2)),
                'net': int(stats_match.group(3))
            }
        
        changes.append(Change(timestamp, categories, stats, file_name))
    
    return changes

def generate_timeline(changes: List[Change], output_dir: str, file_name: str):
    """Generate a visual timeline using Graphviz."""
    dot = graphviz.Digraph(comment=f'Code Evolution Timeline for {file_name}')
    dot.attr(rankdir='LR')  # Left to right layout
    
    # Node attributes
    dot.attr('node', shape='box', style='rounded,filled', fillcolor='lightblue')
    
    # Add nodes and edges
    prev_node = None
    for i, change in enumerate(changes):
        # Create node label with timestamp and categories
        label = f"{change.timestamp}\\n"
        if change.stats:
            label += f"+{change.stats['added']}/-{change.stats['removed']}\\n"
        if change.categories:
            label += "\\n".join(change.categories[:3])  # Show top 3 categories
            if len(change.categories) > 3:
                label += f"\\n(+{len(change.categories) - 3} more)"
        
        # Create node
        node_id = f"change_{i}"
        dot.node(node_id, label)
        
        # Add edge from previous node
        if prev_node is not None:
            dot.edge(prev_node, node_id)
        
        prev_node = node_id
    
    # Save the timeline
    output_path = os.path.join(output_dir, f"{file_name}_timeline")
    dot.render(output_path, format='png', cleanup=True)
    return f"{output_path}.png"

def main():
    """Main function to process markdown files and generate timelines."""
    if len(sys.argv) < 2:
        print("Usage: timeline_generator.py <output_dir> [markdown_files...]")
        sys.exit(1)
    
    output_dir = sys.argv[1]
    markdown_files = sys.argv[2:]
    
    # If no markdown files specified, find all in output directory
    if not markdown_files:
        markdown_files = [
            os.path.join(output_dir, f) for f in os.listdir(output_dir)
            if f.endswith('_changes.md')
        ]
    
    # Process each markdown file
    for md_file in markdown_files:
        try:
            changes = parse_markdown_file(md_file)
            if changes:
                file_name = changes[0].file_name
                timeline_path = generate_timeline(changes, output_dir, file_name)
                print(f"Generated timeline for {file_name}: {timeline_path}")
        except Exception as e:
            print(f"Error processing {md_file}: {e}", file=sys.stderr)

if __name__ == '__main__':
    main() 